## コールバック地獄を再現する

```js
console.log(1);
// settimeoutというapiを使って、1秒後にコンソールに2を表示し、さらに1秒後にコンソールに3を表示する
setTimeout(() => {
  console.log("1秒経ったよ");
  setTimeout(() => {
    console.log("1秒経ったよ");
    setTimeout(() => {
      console.log("1秒経ったよ");
    }, 1000);
  }, 1000);
}, 1000);

console.log(3);
```

## なぜ地獄だったのか？

コールバックに渡した非同期処理の値結果に基づいて、該当の非同期処理を完了したら、同期的に非同期処理を行いたいという場合に、上記のような連続したコードを書かなければいけなかった。

### 問題点

- 処理が膨大になるにつれて、同じことを何度も繰り返す必要が出てくるため、ネストが深くなる
- `try-catxh`を各コールバックで使用する必要があるため、エラーハンドリングが複雑になってしまう
- `setTimeout`は非同期実行されるためコードの実行順序が見た目と違う（不順）
- 複数の非同期処理を並行して実行する場合、このパターンでは管理が難しい
- 読みづらい、保守性が悪い、書きづらい
